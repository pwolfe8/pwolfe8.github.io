<script>

// global variables
var user;
var green_player, blue_player;
var player_arr;


// main
function startGame() {
    myGameArea.start();
    green_player = new Player(30, 30, "green", 17,  17, 0, 0, 2);
    blue_player  = new Player(30, 30, "blue",  17, 283, 1,-1, 1);
    player_arr = [green_player, blue_player];
    user = green_player;
}

// gameplay area
var myGameArea = {
    // grab canvas from html doc
    canvas : document.getElementById('game1'),
    
    // start canvas
    start : function() {
        this.canvas.width = 512;
        this.canvas.height = 300;
        this.context = this.canvas.getContext("2d");

    // update game area every 20th milisecond (50times/sec)
        this.interval = setInterval(updateGameArea, 20);

    // listen to player
        // keyboard strokes
        window.addEventListener('keydown', function(e) {
            myGameArea.keys = (myGameArea.keys || []);
            myGameArea.keys[e.keyCode] = true;
        })
        window.addEventListener('keyup', function(e) {
            myGameArea.keys[e.keyCode] = false;
        })

        // mouse
        window.addEventListener('mousemove', function(e) {
            var rect = myGameArea.canvas.getBoundingClientRect();
            myGameArea.mouse_x = e.clientX - rect.left;
            myGameArea.mouse_y = e.clientY - rect.top;
        })

        // touch
        // window.addEventListener('touchmove', function (e) {
        //     myGameArea.x = e.touches[0].screenX;
        //     myGameArea.y = e.touches[0].screenY;
        // })
    },

    // clear canvas
    clear : function() {
        this.context.clearRect(0,0, this.canvas.width, this.canvas.height);
    }
}

// updates the game area
function updateGameArea() {
    myGameArea.clear();

    decode_user_input();

    // calculate new positions
    for(i=0; i<player_arr.length;i++) { player_arr[i].move(); }
    
    // update
    for(i=0; i<player_arr.length;i++) { player_arr[i].redraw(); }

}

// decodes all the types of user input
function decode_user_input() {
    decode_key_press();
    decode_mouse_move();
    // decode_touch();
}

// decode user's key presses
function decode_key_press() {
    // reset players velocity
    user.vel_x = 0;
    user.vel_y = 0;
    // decode what velocities to add
    var sp = user.speed;
    if(!myGameArea.canvas.onmousemove) {
        if ( myGameArea.keys && myGameArea.keys[37] ) {user.vel_x = -sp} // left
        if ( myGameArea.keys && myGameArea.keys[38] ) {user.vel_y = -sp} // up
        if ( myGameArea.keys && myGameArea.keys[39] ) {user.vel_x =  sp} // right
        if ( myGameArea.keys && myGameArea.keys[40] ) {user.vel_y =  sp} // down
    }
}

// decode user's mouse position
function decode_mouse_move() {
    if (!myGameArea.keys && myGameArea.mouse_x && myGameArea.mouse_y) {
        user.x = myGameArea.mouse_x;
        user.y = myGameArea.mouse_y;
    }
}

// decode user's touch inputs
// function decode_touch() {

// }




// Player class
function Player(width, height, color, init_x, init_y, init_vel_x, init_vel_y, init_speed) {
    this.width = width;
    this.height = height;
    this.x = init_x;
    this.y = init_y;
    this.vel_x = init_vel_x;
    this.vel_y = init_vel_y;
    this.speed = init_speed;

    // moves coordinates to new position
    this.move = function() { 
        this.x += this.vel_x;
        this.y += this.vel_y;
    }

    // redraws the player
    this.redraw = function() {
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
    }
}

</script>
